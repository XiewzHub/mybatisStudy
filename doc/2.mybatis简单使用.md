# Mybatis相关概念

## 1. 对象/关系数据库映射（ORM）

ORM全称Object/Relation Mapping：表示对象-关系映射的缩写 

ORM把关系数据库包装成面向对象的模型。ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。 

## 2. Mybatis简介

MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO （Plain Old Java Objects,普通老式Java对 象）为数据库中的记录。 

## 3. Mybatis优势

Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编码进行分离，功能边界清晰，一个专注业务，一个专注数据。 

# Mybatis基本应用

## 1. 步骤

①添加MyBatis的依赖包

②创建user数据表

③编写User实体类

④编写核心文件SqlMapConfig.xml

⑤编写映射文件UserMapper.xml

⑥编写测试类 

## 2. 代码编写与解析

- 源码[链接  点击跳转](../mybatis_quickStarter)

- 配置文件：

    `sqlMapConfig.xml`文件需要的文件头：

    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-config.dtd">
    ```

    `UserMapper.xml`需要的头：

    ```xml
    <?xml version="1.0" encoding="UTF-8" ?>
    <!DOCTYPE mapper
            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
    ```

- 传统开发方式

  ```java
      @Test
      public void test1() throws IOException {
          // 1.Resources工具类，配置文件的加载，把配置文件加载成字节输入流
          InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
          //2.解析了配置文件，并创建了sqlSessionFactory工厂
          SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
  
          //3.生产sqlSession
          // 默认开启一个事务，但是该事务不会自动提交
          //在进行增删改操作时，要手动提交事务
          SqlSession sqlSession = sessionFactory.openSession();
  
          // 4.sqlSession调用方法：查询所有selectList 查询单个：selectOne 添加：insert  修改：update 删除：delete
          List<User> users = sqlSession.selectList("com.xiewz.dao.IUserDao.findAll");
  
          for (User user : users) {
              System.out.println(user);
          }
  
          // 5. 释放资源
          sqlSession.close();
      }
  
      @Test
      public void test2() throws IOException {
          InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
          SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
          SqlSession sqlSession = sqlSessionFactory.openSession();
  
          User user = new User();
          user.setId(4);
          user.setUsername("lucy");
          sqlSession.update("com.xiewz.dao.IUserDao.updateUser",user);
          // 增删改操作需要手动commit
          sqlSession.commit();
  
          sqlSession.close();
      }
  ```

  每次执行数据库操作都是由sqlSession开启调用。

  **注意点：**

  1. SqlSession执行完后记得释放资源

  2. sessionFactory.openSession()获取的SqlSession不会自动提交事务，每次执行完增、删、改操作都需要手动commit

- 代理开发方式

  mybatis使用代理模式来实现Dao层。

  Mapper 接口开发需要遵循以下规范 

  **1 Mapper.xml文件中的namespace与mapper接口的全限定名相同** 

  **2 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同** 

  **3 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同** 

  **4 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同** 

  ![mapper对应图](img\mapper对应图.png)

  编写UserMapper接口

  ```java
  @Test
      public void test3() throws IOException {
          // 1.Resources工具类，配置文件的加载，把配置文件加载成字节输入流
          InputStream resourceAsStream = Resources.getResourceAsStream("sqlMapConfig.xml");
          //2.解析了配置文件，并创建了sqlSessionFactory工厂
          SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
          //3.生产sqlSession
          SqlSession sqlSession = sessionFactory.openSession();
  
          int[] ids = {1,2};
          // 获取动态代理对象 代理实现了IUserDao接口
          IUserDao mapper = sqlSession.getMapper(IUserDao.class);
          List<User> userList = mapper.findByIds(ids);
  
          for (User user : userList) {
              System.out.println(user);
          }
  
          // 5. 释放资源
          sqlSession.close();
      }
  ```

  其中`IUserDao mapper = sqlSession.getMapper(IUserDao.class);`就获取了代理实现



# Mybatis配置文件

## 1. 核心配置文件SqlMapConfig.xml 

- configuration  配置
  - properties  属性
  - setting 设置
  - typeAliases 别名
  - typeHandlers 类型处理器
  - objectFactory 对象工程
  - plugins 插件
  - environments 
    - environment 环境变量
      - transactionManager 事务管理器
      - dataSource 数据源
  - databaseIdProvider 数据库厂商标识
  - mappers 映射器

## 2. MyBatis常用配置解析 

### environments标签 

数据库环境的配置，支持多环境配置 

其中，事务管理器（transactionManager）类型有两种：
•JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。
•MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将closeConnection 属性设置为 false 来阻止它默认的关闭行为。其中，数据源（dataSource）类型有三种：
•UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。
•POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。 
•JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。 

## 3. 映射配置文件mapper.xml 





**todo**

# Mybatis复杂映射开发

## 1. 一对一查询

一对一查询，也就是两张表的数据连接成一个结果，如下面查询语句的结果

```sql
select * from orders o,user u where o.id=u.id
```

此时查出了用户信息与订单信息

代码准备：

1. 创建配置文件 `IUserMapper.xml`、`jdbc.properties`、`sqlMapConfig.xml`
2. 创建实体类，User和Order
3. 创建IUserMapper

注意：

1. 可以在Order实体中新增User属性

   ```java
   public class Order {
   
       private Integer id;
       private String orderTime;
       private Double total;
   
       // 表明该订单属于哪个用户
       private User user;
   }
   ```

2. `Mapper.xml`文件中，两个表的id同名，会有问题

   所以需要定义`resultMap`的时候需要定义`association`

   ```xml
   <resultMap id="orderMap" type="com.xiewz.pojo.Order">
           <result property="id" column="id"></result>
           <result property="orderTime" column="orderTime"></result>
           <result property="total" column="total"></result>
           <association property="user" javaType="com.xiewz.pojo.User">
               <result property="id" column="uid"></result>
               <result property="username" column="username"></result>
           </association>
       </resultMap>
   ```

   

## 2. 一对多查询

一个用户对应多个订单时，属于一对多查询，查询出user，同时查询出订单list

注意在resultMap中定义Order集合`collection`如下：

```xml
<resultMap id="userMap" type="com.xiewz.pojo.User">
        <result property="id" column="id"></result>
        <result property="username" column="username"></result>
        <collection property="orderList" ofType="com.xiewz.pojo.Order">
            <result property="id" column="oid"></result>
            <result property="orderTime" column="ordertime"></result>
            <result property="total" column="total"></result>
        </collection>
    </resultMap>
```



## 3. 多对多查询

一个用户对应多个角色，同时一个角色可以对于多个用户，属于多对多查询，resultMap定义

```xml
   <resultMap id="userRoleMap" type="com.xiewz.pojo.User">
        <result property="id" column="userid"></result>
        <result property="username" column="username"></result>
        <collection property="roles" ofType="com.xiewz.pojo.Role">
            <result property="id" column="roleid"></result>
            <result property="roleName" column="roleName"></result>
            <result property="roleDesc" column="roleDesc"></result>
        </collection>
    </resultMap>
```



# Mybatis注解开发

## 增删查改

```java
public interface IUserMapper {
    // 添加用户
    @Insert("insert into user values(#{id},#{username})")
    void addUser(User user);

    //更新用户
    @Update("update user set username = #{username} where id = #{id}")
    public void updateUser(User user);

    //查询用户
    @Select("select * from user")
    public List<User> selectUser();

    //删除用户
    @Delete("delete from user where id = #{id}")
    public void deleteUser(Integer id);
}
```



## 1. 一对一查询

**@One 代替`association**`

接口注解改为一下例子：

1 修改`IOrderMapper.java`增加注解，并指向User查询

```java
@Results({
            @Result(property = "id",column = "id"),
            @Result(property = "orderTime",column = "orderTime"),
            @Result(property = "total",column = "total"),
            @Result(property = "user",column = "uid",javaType = User.class,
                    one=@One(select = "com.xiewz.mapper.IUserMapper.findUserById"))
    })
@Select("select * from orders")
public List<Order> findOrderAndUser();
```

2 修改`IUserMapper.java`增加方法

```java
@Select({"select * from user where id = #{id}"})
public User findUserById(Integer id);
```

3 此时，调用findOrderAndUser()方法时，同时会通过`uid` 关联查询User信息

![](img/注解一对多调用过程.png)

## 2. 一对多查询

**@Many 代替`collection**`

## 3. 多对多查询































































